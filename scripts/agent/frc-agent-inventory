#!/usr/bin/env bash
set -euo pipefail

error() {
  echo "frc-agent-inventory: $*" >&2
}

require_env() {
  local name="$1"
  if [[ -z "${!name:-}" ]]; then
    error "Missing required env var: $name"
    exit 1
  fi
}

require_cmd() {
  local name="$1"
  if ! command -v "$name" >/dev/null 2>&1; then
    error "Missing required command: $name"
    exit 1
  fi
}

require_env FRC_URL
require_env FRC_API_KEY
require_env FRC_AGENT_ID
if [[ -z "${FRC_AGENT_SECRET:-}" && -n "${AGENT_HMAC_SECRET:-}" ]]; then
  FRC_AGENT_SECRET="${AGENT_HMAC_SECRET}"
fi
require_env FRC_AGENT_SECRET

require_cmd curl
require_cmd openssl
require_cmd python3

timestamp="$(date +%s)"
server_name="$(hostname -f 2>/dev/null || hostname)"
url="${FRC_URL%/}/api/v1/ingest/inventory/"

os_name=""
if [[ -r /etc/os-release ]]; then
  os_name="$(awk -F= '/^PRETTY_NAME=/{print $2}' /etc/os-release | sed 's/^"//;s/"$//')"
fi

kernel="$(uname -r 2>/dev/null || echo "")"
uptime_seconds=""
if [[ -r /proc/uptime ]]; then
  uptime_seconds="$(awk '{print int($1)}' /proc/uptime 2>/dev/null || echo "")"
fi

public_ip_candidate=""
if command -v ip >/dev/null 2>&1; then
  public_ip_candidate="$(ip -4 route get 1.1.1.1 2>/dev/null | awk '/src/ {for (i=1; i<=NF; i++) if ($i=="src") {print $(i+1); exit}}')"
fi

ports_file="$(mktemp)"
services_file="$(mktemp)"
containers_file="$(mktemp)"
trap 'rm -f "$ports_file" "$services_file" "$containers_file"' EXIT

if command -v ss >/dev/null 2>&1; then
  ss -tuln 2>/dev/null | tail -n +2 | awk '{print $1 "\t" $5}' > "$ports_file"
elif command -v netstat >/dev/null 2>&1; then
  netstat -tuln 2>/dev/null | tail -n +3 | awk '{print $1 "\t" $4}' > "$ports_file"
fi

if command -v systemctl >/dev/null 2>&1; then
  systemctl list-units --type=service --all --no-pager --no-legend | while read -r line; do
    [[ -z "$line" ]] && continue
    name="$(echo "$line" | awk '{print $1}')"
    state="$(echo "$line" | awk '{print $3}')"
    enabled="$(systemctl is-enabled "$name" 2>/dev/null || echo "disabled")"
    printf '%s\t%s\t%s\n' "$name" "$state" "$enabled" >> "$services_file"
  done
fi

if command -v podman >/dev/null 2>&1; then
  podman ps --format '{{.Names}}\t{{.Image}}\t{{.Status}}' | while IFS=$'\t' read -r name image status; do
    [[ -z "$name" ]] && continue
    printf 'podman\t%s\t%s\t%s\n' "$name" "$image" "$status" >> "$containers_file"
  done
fi

if command -v docker >/dev/null 2>&1; then
  docker ps --format '{{.Names}}\t{{.Image}}\t{{.Status}}' | while IFS=$'\t' read -r name image status; do
    [[ -z "$name" ]] && continue
    printf 'docker\t%s\t%s\t%s\n' "$name" "$image" "$status" >> "$containers_file"
  done
fi

body="$(
  python3 - "$server_name" "$timestamp" "$os_name" "$kernel" "$uptime_seconds" "$public_ip_candidate" "$ports_file" "$services_file" "$containers_file" <<'PY'
import ipaddress
import json
import sys

server_name = sys.argv[1]
timestamp = int(sys.argv[2])
os_name = sys.argv[3]
kernel = sys.argv[4]
uptime_raw = sys.argv[5]
public_ip_candidate = sys.argv[6]
ports_path = sys.argv[7]
services_path = sys.argv[8]
containers_path = sys.argv[9]

def parse_ports(path):
    ports = []
    try:
        with open(path, "r", encoding="utf-8") as handle:
            for line in handle:
                line = line.strip()
                if not line:
                    continue
                parts = line.split("\t", 1)
                if len(parts) != 2:
                    continue
                proto, local = parts[0].lower(), parts[1]
                local = local.strip()
                if not local:
                    continue
                if local.startswith("[") and "]" in local:
                    addr, port = local.rsplit("]:", 1)
                    addr = addr.lstrip("[")
                else:
                    if local.count(":") > 1:
                        addr, port = local.rsplit(":", 1)
                    elif ":" in local:
                        addr, port = local.rsplit(":", 1)
                    else:
                        addr, port = local, ""
                addr = addr.split("%")[0]
                if not port.isdigit():
                    continue
                ports.append({"proto": proto, "address": addr, "port": int(port)})
    except FileNotFoundError:
        return []
    return ports

def parse_services(path):
    services = []
    try:
        with open(path, "r", encoding="utf-8") as handle:
            for line in handle:
                line = line.strip()
                if not line:
                    continue
                parts = line.split("\t")
                if len(parts) < 3:
                    continue
                name, state, enabled = parts[0], parts[1], parts[2]
                services.append({
                    "name": name,
                    "state": state,
                    "enabled": enabled == "enabled",
                })
    except FileNotFoundError:
        return []
    return services

def parse_containers(path):
    containers = []
    try:
        with open(path, "r", encoding="utf-8") as handle:
            for line in handle:
                line = line.rstrip("\n")
                if not line:
                    continue
                parts = line.split("\t")
                if len(parts) < 4:
                    continue
                runtime, name, image, status = parts[0], parts[1], parts[2], parts[3]
                containers.append({
                    "runtime": runtime,
                    "name": name,
                    "image": image,
                    "state": status,
                })
    except FileNotFoundError:
        return []
    return containers

public_ip = None
if public_ip_candidate:
    try:
        ip = ipaddress.ip_address(public_ip_candidate)
        if ip.is_global:
            public_ip = public_ip_candidate
    except ValueError:
        public_ip = None

try:
    uptime_seconds = int(float(uptime_raw))
except (TypeError, ValueError):
    uptime_seconds = None

payload = {
    "hostname": server_name,
    "os": os_name or None,
    "kernel": kernel or None,
    "uptime_seconds": uptime_seconds,
    "public_ip": public_ip,
    "listening_ports": parse_ports(ports_path),
    "services": parse_services(services_path),
    "containers": parse_containers(containers_path),
}

data = {
    "server_name": server_name,
    "timestamp": timestamp,
    "payload": payload,
}

print(json.dumps(data, separators=(",", ":")))
PY
)"

if [[ "${FRC_DRY_RUN:-}" == "1" ]]; then
  echo "$body"
  exit 0
fi

signature="$(printf '%s' "$body" | openssl dgst -sha256 -hmac "$FRC_AGENT_SECRET" -hex | awk '{print $2}')"
response_file="$(mktemp)"
http_code="$(
  curl -sS -o "$response_file" -w "%{http_code}" \
    -H "Content-Type: application/json" \
    -H "X-API-Key: $FRC_API_KEY" \
    -H "X-Agent-Id: $FRC_AGENT_ID" \
    -H "X-Timestamp: $timestamp" \
    -H "X-Signature: $signature" \
    --data-binary "$body" \
    "$url"
)"

if [[ "$http_code" != 202 && "$http_code" != 200 && "$http_code" != 201 ]]; then
  error "Request failed with HTTP $http_code"
  cat "$response_file" >&2 || true
  rm -f "$response_file"
  exit 1
fi

cat "$response_file"
rm -f "$response_file"
